#!/usr/bin/env ruby
require 'gli'
begin # XXX: Remove this begin/rescue before distributing your app
require 'pushare'
rescue LoadError => ex
  STDERR.puts "In development, you need to use `bundle exec bin/todo` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/todo now"
  puts ex.inspect
  exit 64
end

include GLI::App

program_desc 'Describe your application here'

version Pushare::VERSION

desc 'Debug'
switch [:d,:debug]

desc 'config'
default_value 'pushare.yml'
arg_name 'Configuration file'
flag [:c,:config]

desc 'id'
default_value 'client'
arg_name 'Agent id'
flag [:i,:id]

desc 'server'
arg_name ''
command :server do |c|
  c.action do |global_options,options,args|
    init_config(global_options,options,args)

    agent = Pushare::Agent.new(@config,:server,:client)

    client_thread = Thread.new do
      client = Pushare::Agent.new(@config,:client,:server)
      _chan,_event = client.guff(:control,:onKey)
      client.socket[_chan].bind(_event) do |data|
        client.onKey(_chan,_event,data)
      end
      client.connect
    end

    _chan,_event = agent.guff(:data,:onData)
    agent.socket[_chan].bind(_event) do |data|
      agent.onData(_chan,_event,data)
    end

    # key loop
    agent.control_thread

    # main loop
    agent.connect
  end
end


desc 'client'
arg_name ''
command :client do |c|
  c.action do |global_options,options,args|
    init_config(global_options,options,args)

    agent = Pushare::Agent.new(@config,:client,:server)

    # events
    _chan,_event = agent.guff(:control,:onKey)
    agent.socket[_chan].bind(_event) do |data|
      agent.onKey(_chan,_event,data)
    end

    _chan,_event = agent.guff(:control,:onExit)
    agent.socket[_chan].bind(_event) do |data|
      agent.onExit(_chan,_event,data)
    end

    # data loop
    agent.data_thread
   
    # main loop
    agent.connect
  end
end



pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  # true
  begin
    @config = YAML.load(ERB.new(File.read(global[:config])).result)
  rescue Exception => e
    STDERR.puts "pre #{e.message}"
  end
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  puts exception.backtrace
  true
end

def init_config(global_options,options,args)
  puts "Global:  #{global_options.inspect}"
  puts "Options: #{options.inspect}"
  puts "Args:    #{args.inspect}"
  @config[:pushare][:id] = global_options[:id] if global_options.has_key? :id
  @config[:pushare][:args] = args
  @config[:pushare][:global_options] = global_options
  @config[:pushare][:options] = options
  Pusher.app_id = @config[:pushare][:pusher][:app_id]
  Pusher.key = @config[:pushare][:pusher][:key]
  Pusher.secret = @config[:pushare][:pusher][:secret]
  Pusher.encrypted = true
  PusherClient.logger = Logger.new(STDOUT)
  PusherClient.logger.level = Logger::WARN
end

exit run(ARGV)
